use std::collections::HashSet;
use std::cmp;

// utils
pub fn get_primes(n: i64) -> Vec<i64> {
    let mut primes: Vec<i64> = vec!();
    let mut not_primes = vec![1; (n+2) as usize];
    let mut i = 2;
    loop {
        if not_primes[i] == 1 {
            primes.push(i as i64);
            let mut j = i;
            loop {
                j += i;
                if j > (n as usize) { break }
                not_primes[j] = 0;
            }
        }
        i += 1;
        if i > (n as usize) { break }
    }
    primes
}



// solves project euler projects

/*
1. If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below 1000.
*/
pub fn problem_1() -> i64 {
    let mut xs = vec!();
    for i in 1..1000 {
        if i % 3 == 0 || i % 5 == 0 {
            xs.push(i)
        }
    }
    xs.iter().sum()
}


/*
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:
1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*/
fn problem_2() -> i64 {
    let mut fib = vec![1, 2];
    let mut a = 1;
    let mut b = 2;
    let mut c;
    let limit = 4_000_000;
    loop {
        c = a + b;
        a = b;
        b = c;
        if c > limit { break; }
        fib.push(c);
    }
    fib.iter().filter(|&x| x % 2 == 0).sum()
}


/*
The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143 ?
*/
pub fn problem_3() -> i64 {
    let n: i64 = 600851475143;
    let mut primes = vec!();
    let mut t = n;
    let mut i = 2;
    loop {
        if t % i == 0 {
            t = t / i;
            primes.push(i);
        }
        if t <= 1 {
            break
        }
        i += 1;
    }
    primes[primes.len()-1]
}


/*
A palindromic number reads the same both ways.
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
Find the largest palindrome made from the product of two 3-digit numbers.
*/
pub fn is_palindrome(n: i64) -> bool {
    let n_str = n.to_string();
    let n_len = n_str.len() as i64;
    if n_len < 2 {
        return false;
    }
    let half: i64 = n_len / 2;
    for i in 0..half {
        if n_str.chars().nth(i as usize) != n_str.chars().nth((n_len - 1 - i) as usize) {
            return false;
        }
    }
    true
}

pub fn problem_4() -> i64 {
    let mut palindrome = 0;
    for i in (0..999).rev() {
        for j in (0..999).rev() {
            let t = i * j;
            if is_palindrome(t) {
                palindrome = cmp::max(palindrome, t);
            }
        }
    }
    palindrome
}


/*
2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*/
pub fn problem_5() -> i64 {
    let mut c = 1;
    let h = 20;
    let p = get_primes(20);
    let mut prime_product = 1;
    for i in p {
        prime_product = prime_product * i;
    }
    let mut x;
    loop {
        x = prime_product * c;
        c += 1;
        let mut divisible = true;
        for i in 2..h {
            if x % i != 0 {
                divisible = false;
                break
            }
        }
        if divisible { break }
    }
    x
}


/*
Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
*/
pub fn problem_6() -> i64 {
    let n = 100;
    let mut sum_sq = 0;
    let mut sum = 0;
    // sum of squares
    for i in 1..(n+1) {
        sum_sq += i*i;
        sum += i;
    }
    sum * sum - sum_sq
}

/*
What is the 10 001st prime number?
*/
pub fn problem_7() -> i64 {
    let p = get_primes(120000);
    p[10_001-1]
}


/*
Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?
*/
pub fn problem_8() -> i64 {
    let n = 13;
    let digits = "73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450";
    let digits2 = &digits.replace("\n", "");
    // convert to vec
    let mut array = vec!();
    for i in 0..digits2.len() {
        let ch = digits2.chars().nth(i).unwrap();
        array.push(ch.to_digit(10).unwrap());
    }
    let mut max = 0;
    let mut i = 0;
    loop {
        if i + 13 > array.len() {
            break
        }
        let mut sum: i64 = 1;
        for j in i..(i+n) {
            sum = sum * array[j] as i64;
            max = cmp::max(max, sum);
        }
        i += 1;
    }
    max as i64
}


/*
There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
*/
pub fn problem_9() -> i64 {
    let n = 200000;
    let mut i = 0;
    let mut seq = vec!();
    loop {
        let j = i*i;
        if j > n { break }
        seq.push(j);
        i += 1;
    }
    for i in 0..seq.len() {
        for j in i..seq.len() {
            let s = i*i + j*j;
            let k_res = seq.binary_search_by(|probe| probe.cmp(&s));
            if k_res.is_ok() {
                let k = k_res.unwrap();
                let sum = i + j + k;
                if sum == 1000 {
                    return (i*j*k) as i64;
                }
            }

        }
    }
    0
}


/*
Find the sum of all the primes below two million.
*/
pub fn problem_10() -> i64 {
    let n = 2_000_000;
    let primes = get_primes(n);
    let mut s = 0;
    for p in primes.iter() {
        if *p > n { break }
        s += p;
    }
    s
}


pub fn solutions() {
    let answer1 = problem_1();
    let answer2 = problem_2();
    let answer3 = problem_3();
    let answer4 = problem_4();
    let answer5 = problem_5();
    let answer6 = problem_6();
    let answer7 = problem_7();
}
